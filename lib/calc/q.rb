module Calc
  class Q
    def **(other)
      power(other)
    end

    # Inverse gudermannian function
    #
    # @param eps [Calc::Q] (optional) calculation accuracy
    # @return [Calc::Q,Calc::C]
    # @example
    #  Calc::Q(1).agd #=> Calc::Q(1.22619117088351707081)
    #  Calc::Q(2).agd #=> Calc::C(1.5234524435626735209-3.14159265358979323846i)
    def agd(*args)
      r = Calc::C(self).agd(*args)
      r.real? ? r.re : r
    end

    # Returns 1 if binary bit y is set in self, otherwise 0.
    #
    # @param y [Numeric] bit position
    # @return [Calc::Q]
    # @example
    #  Calc::Q(9).bit(0) #=> Calc::Q(1)
    #  Calc::Q(9).bit(1) #=> Calc::Q(0)
    # @see bit?
    def bit(y)
      self.class.new(bit?(y) ? 1 : 0)
    end

    def cbrt
      root(3)
    end

    # Gudermannian function
    # 
    # @param eps [Calc::Q] (optional) calculation accuracy
    # @return [Calc::Q]
    # @example
    #  Calc::Q(1).gd #=> Calc::Q(0.86576948323965862429)
    def gd(*args)
      r = Calc::C(self).gd(*args)
      r.real? ? r.re : r
    end

    def im
      Calc::Q(0)
    end

    def inspect
      "Calc::Q(#{ to_s })"
    end

    def isimag
      false
    end

    def isreal
      true
    end

    def re
      self
    end

    def sqrt
      root(2)
    end

    # libcalc has no concept of floating point numbers.  so we use ruby's
    # Rational#to_f
    def to_f
      self.to_r.to_f
    end

    # convert to a core ruby Rational
    def to_r
      Rational(self.numerator.to_i, self.denominator.to_i)
    end

    alias imag im
    alias imag? isimag
    alias real? isreal
    alias real re
  end
end
